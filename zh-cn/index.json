[{"categories":["learn"],"content":"简要总结下本科课程 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:0:0","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"First Year 大一，可以说就是把国内高中的东西拿英文重新上一遍，压力很小，几乎每天都有时间健身。两个工程导论课还算有意思，小组讨论的形式很锻炼口语。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:0","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"APSC 100/101 工程学导论，主要介绍工程项目的设计流程和方法，以及与环境和经济的关系。有教授 SolidWorks 的基本用法和 3D 打印技术的简单介绍。两个动手的项目，分别是 Term1 的纸板椅子和 Term2 的 Arduino 夹子。我们纸板椅的设计以折叠为主，用 SW 钣金功能极大简化了设计难度。实测 75kg 的人直接屁股坐上去不成问题。不过最后测试时重量是压在两只鞋上，导致只有部分结构在实际承重. Arduino 夹子没啥好说的，编程部分就是个超声波和舵机，非常简单，更多在动手剪铝板压铆钉上。 课程里几个印象深刻的点： Design Process 核心在于，将问题分解为多个维度的评价标准 (evaluation criteria), 并对头脑风暴出来的众多方案中可行的几个打分。 C-Sketch 非常有趣的头脑风暴方案，避免了 “某人看起来很专业所以听他的就好了” 这种事发生。做法是每个人 10 分钟画一张画表达自己的想法，期间不许语言交流。画完后传给下个人，下个人继续用 5 分钟把他对这个方案的理解补充上去，以此循环，直至轮转完一圈。如果说完全没有绘画技巧，那理解起来就比较抽象了。最好学一下基本的透视，方块和曲线的画法。 关于设计流程的部分其实来自某教授的一本书，虽然内容不错但也太贵了吧…后面 MECH2 还会再提到。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:1","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"APSC 160 少儿编程难度的 C 语言，当然人家正式名称叫做编程在工程中的应用… 考试是手写代码。平时的 lab 很有意思，有一套 daq 系统和外界交互，需要 Visual Studio，因为 daq 以及模拟器的库是 Windows 平台的 dll… 当时对编译过程一窍不通的我试图用 mingw gcc 未果，不过理论上应当是可以的。 推荐教材是本没听说过的书 Programming in C, 虽然课并没按教材讲，而且只覆盖了 1/3 不到的内容，但我在暑假把整本书看完了。难度很低，没有算法，没有任何宏之类的奇技淫巧，可以说是很好的 C 语言入门材料了。说来也怪，我靠学 C 把当初看廖雪峰 Python 没看懂的 OO 搞明白了。看到结构体和函数指针，立马手撸了个多态; 结构体套结构体，也算实现了继承; 至于封装…不知道该怎么实现，毕竟结构体的声明里一定暴露了所有成员呀… ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:2","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"PHYS 157/158 普高难度的物理，只是用英文讲，没啥好说的 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:3","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"PHYS 170 力学初步，极坐标柱坐标转换什么的有点烧脑，不过背公式就完了。考试非常简单。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:4","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"CHEM 154 普高难度的化学，加上一些定性的东西需要背一下，电子轨道理论高中没学，需要补补。难度基本在背单词 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:5","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"ENGL 112 英语课，学术写作，讲一些用词行文以及引用参考文献的规范。说实话听不太懂，final 直接让写一篇 400 词文章。我托福都没写过这么多… ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:6","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MATH 100/101 微积分，国内大先那套 $\\epsilon-\\delta$ 语言真的是上吐了，这里不讲推导所以简单很多，毕竟工科嘛，会用就行。作业题感觉很简单但不知道为啥 final 分不高… ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:7","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MATH 152 线性代数入门。到特征值特征向量以及特征值法解微分方程就结束了，难度不大。我的 Prof Yuexian Li 是个中国人，以前看过简历，似乎是中科大的本科，然后 80 年代中科院的研究生！课上的非常好，以至于后来我去看大家吹的 3B1B 只觉得无感，当然线代这玩意儿入门真就是会者不难。有 Lab 会教你 MATLAB 的基本使用。总的来说很实用，体验很好的一门课。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:8","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"FREN 100 Summer 赶上疫情，上的网课。用英语讲的法语课。以敢开口为主，气氛比较欢乐，当然单词肯定是得背。考试有口语和笔试两场。感叹一下加拿大同学确实很多都有法语基础呀… 和我一组的一个同学是歌剧系的，唱过法语歌词。另外她家在 Newfoundland，当时每天顶着时差上课… ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:9","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"LING 101 一样的网课，上课就像听故事。主要讲了国际音标以及从音位推断一些语言的关系。因为本身对这方面很有兴趣所以上起来很舒服，刷知乎看到方言还有古汉语等等话题总算能看懂一些了。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:10","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH2 大二，因为疫情回国全程网课。机械系大二比较特殊，全年级上同一套课表，没得选。而且 Term1 分成三段：机械制图和 Arduino，几门正课 和 工程导论. Term 2 也是分了两段，正课和最后的小项目。对于我们这些在另一个半球的学生，系里很贴心的准备了所有课的录播，lab session, tutorial, weekly quiz 也都有两个时区. Final 也选在了对大部分学生都合适的时间。相比其他专业的同学不得不上夜校，真的要吹爆 MECH. 另外，考试被安排在了大部分同学都合适的时区。而且由于网课，Symbolab 什么的全凭自觉，但我用 Python 写几个求解器应该不过分吧。 大二总算有那么一点点大学的样子了，大一上得太舒服，都快忘记学习的感觉了。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:2:0","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 230 Arduino 玩 Autodesk 出的一个模拟器, 极其简单。 机械制图 上这课时我在隔离酒店…要用的图纸却寄到家里去了…只好拜托防疫人员帮忙打印…体验极差。内容主要是三视图，剖面图和尺寸标注。但相贯线之类的却只要求画个大概就行… ANSI 和 ISO 两套标准都讲了，但考试还是 ANSI. ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:2:1","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 232/233 继续工程导论，在 APSC 100/101 的基础上继续扩展。强制买某教授的书确实有点恶心，还没法寄国内，不过还好有热心同学拍照分享。 232 直接虚空设计，算算就完事儿了. 233 要求做个爬绳器，因为疫情，最后性能就比个乐，不算分。既然在中国那自然淘宝铝板定制走起。轴承什么的更是想选啥买啥。可惜发货都在深圳，早知道让寄深圳那个同学那边去好了。还省得我组装了 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:3:0","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 221/222 所谓正课，倍速大屏看录播真的不要太爽。 MATH 常微分方程，雅可比矩阵 和 多元微积分，以及拉普拉斯变换，挺基础的内容，有配套 MATLAB lab. 还是，不讲推导所以难度不大。 Dynamics 刚体动力学。坐标变换，角动量，阻尼振动什么的。概念不难，本质上还是牛顿定律，但算起来有些复杂。 Solid Mechanics 固体力学入门。拉压应力/应变，剪应力/应变的计算，莫尔圆/应力圆，轴上的扭矩，梁的弯矩。内容其实没多少，后面 MECH360 两节课就把这些全带过了。教授也是个中国人，但她讲得实在是太太太慢了…我开两倍速都嫌慢… Statistics 统…计？内容很少的一节课，很快就上完了。写这总结的时候甚至想不起来上了啥… 中位数，均值，众数，简单讲了下最小二乘和置信区间。 Circuit Analysis 电路分析。电流源和电压源的两种等效电路，电容电感，交流电的复数表示和 RLC 电路。 Material 材料学导论。晶体结构，塑性脆性，蠕变，金相。很多定性的东西。已经忘得差不多了。 Fluid Mechanics 流体力学入门。介绍一些基本概念和量纲分析，主要围绕雷诺数，还有管内的流动分析以及水泵。教授声音软软的，但讲课废话有点多…而且还有额外的视频要课前预习…这几乎双倍工作量了吧？ Thermal Dynamics 热力学入门。理想气体状态方程，焓，熵，相变，几种热力学过程和它们的 TS 图。没啥，算就完事儿了。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:3:1","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 226 技术写作。由一个 89 年已经在乌克兰毕业，95 年又来加拿大读博的英语文学专业乌克兰老太太念 ppt. 这门课贯穿整个大二。内容是怎么在公司里写汇报 233. 对于非母语者确实有难度，也确实很实用。但是吧，至少我，这辈子应该达不到这门课能拿 A 的水平了…毕竟语言这东西，尤其是写作，母语者真的一眼就能看出别扭的地方。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:3:2","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"Mechatronics Year 3 机械电子方向大三分两年: Year 3 和 Year 3.5. 大学上到这时候终于算是学了点实用的东西。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:0","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 306 概率统计和实验设计。标准差，均值标准差，正态分布，学生 T 分布，假设检验，F 检验，(配对)T 检验，中心极限定理，贝叶斯定理，泊松分布，指数分布，二项分布，加权平均，拟合，机器学习简介，滤波器，主元分析Principle Component Analysis. 哗哗列了一大堆，感觉都是挺重要的主题，但教授上课和课程内容设计实在太差. 要不是我高中上过概率论与数理统计先修，真的不知道这课在讲什么。概率论上来不讲符号直接放公式，排列组合维恩图什么的直接跳过。统计也一样，上来连随机变量定义都不讲，一个概率密度直接把大家全搞懵。公式推导一概不讲，背住就完事儿。 实验部分也只能算差强人意。三个安排好的实验要从学校拿材料自己在家做，其中流体和热力学实验偏差实在太大，硬件问题也基本无法解决。最后一个自己设计的实验还算勉强，但其实绝大部分组都是搞点数据然后 T 检验或者 F 检验再画个图完事儿，半定量甚至纯定性的分析为主，仔细想想也没有任何成就感可言。 考试体验也极差，期中上课一嘴带过的二项分布做了一整道大题。期末因为每年讲课内容还不一样，历年考题完全不能参考，复习都无从下手。总之是非常让人迷惑的一门课。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:1","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 360 材料力学。梁的弯矩，柱屈曲，能量分析，静不稳定梁的分析，不对称弯曲，剪力中心等等。相当友善的一门课。内容不多，难度不大，所以教授讲得比较慢 习题课 TA 也是. 公式也都很好理解。作业判得比较严，甚至多算了一些东西也要扣分。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:2","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 375 传热基础。传导，对流和辐射，热交换器。教授讲得略微有些奇怪，一上来听着会有些迷惑，但上到最后发现本质其实就是热传导方程 + NS 方程。平时作业题来自某参考书，和讲课内容基本不搭，TA 直接念标答。不过考试还好，因为基本只能参考经验公式，并不会考手解微分方程，按计算器就完事儿了，还有一部分概念简答题。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:3","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"ELEC 302 模电。二极管，PN 结，运放，三极管和 MOS 管。内容多但难度不大，教授语速极快，上课容易跟不上，不过回看 PPT 基本都能看懂. PN 结物理原理有点迷惑，不过明白了也就是一层窗户纸。考试允许带 4 页双面笔记，相当友善。 Lab 部分挫败感极强，四个 LAB 我们两个都没做出来…应该是器材的原因. Lab TA 几乎没有任何作用。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:4","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"ELEC 343 电机入门。三相电，电感，磁链，变压器，直流，步进，同步，无刷，感应电机的基本原理和简单分析。内容有相当的广度和深度，这学期投入最多的一门课。教授讲得也很好。尤其学到磁链，电感，交流，qd 坐标系等等需要数学的地方，能切实感受到数学在工科中的美妙应用。直流和无刷电机还给出了 SimuLink 模型，我也顺带入了个 SimuLink 的门. Lab 工作量相当大，有大量的计算。有时发现数据和理论不符，怀疑是误差，但仔细分析发现还是自己理解不到位，理论值算的有问题. Lab 后面几个问题也相当有深度。摆烂了一个 Lab 实在是很抱歉。 习题和实验课的时间安排有些迷惑，经常上课还没讲就需要做实验做题…因为这个还导致我们某个 Lab 没做出来…还好有去年疫情期间录好的的视频可以抄数据参考。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:5","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"CPEN 312 数电和 8051 汇编。如果看过 Code: The Hidden Language of Computer Hardware and Software编码：隐匿在计算机软硬件背后的语言 这本书，那这门课可以秒杀之。课程分为独立的两段：期中前数电，主要是布尔代数，锁存器，触发器，同步异步计数器，状态机和多路选择器。布尔代数虽然不讲数学证明，但会考 K-Map 化简和纯 NAND 搭任意逻辑等等，虽然之前有过一点了解，但真正学起来还是有些难度. Lab 用 FPGA 做。期中后就是 8051 汇编。讲课内容对新手不太友好，最好有一些计组基础或者单片机 (非 arduino) 经验。除了基本的汇编指令，寄存器，栈和 51 内存结构，还讲了： 数学计算 负数的补码表示 Binary \u003c–\u003e BCD 大于 8 位的无符号加减法 大于 8 位的无符号乘除法 (简单介绍) 中断和定时器 不考但其他年份讲过所以只放出 PPT 的内容： 串口: RS232 SPI 对我而言很轻松的一门课，从此无惧汇编，了解了许多底层细节。老教授这门课教了 20 多年了，FPGA 的 51 软核，汇编器，调试器和 IDE 都是他自己写的. PPT 后面的练习题虽然不讲，但值得一看，比如 51 的栈传参. FPGA 板子是 Intel University Program 的 Altera Cyclone V，优惠价 99 美刀，但还是很贵啊…强制买还是有点肉疼。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:6","tags":null,"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["tech"],"content":"大三才做出来平衡小车实在是太菜了…分享一下过程和学习笔记。写这篇时还没有学过任何控制相关的课程，如有错误请见谅 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:0:0","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"平衡小车 PID 原理 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:0","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"PID 网上有太多 PID 解析了，这里不多赘述，讲一下我的理解 小时候一定拨过钢尺，振幅越来越小最后不振了。能来回振是因为钢尺有弹性，能停下是因为有阻尼。弹簧 + 阻尼一般能解决大部分问题，而这其实就是 PD 控制器。二阶线性微分方程从原理上解释了这一切。忘光了现学的… $$ my’’+cy’+ky=f(t) $$ 用 RLC 电路理解也可以 假设这些参量均大于零，即特征方程的解$r_1 , r_2$的实部$\\frac{-c}{2m}$小于零，则微分方程的通解$y=K_1 e^{r_1 t} + K_2 e^{r_2 t}$一定收敛。理想情况是临界阻尼$r_1 = r_2$, 此时通解为$y=Ke^{rt} + Kte^{rt}$ 因此，PD 控制器可以理解为给原本的模型套上了弹簧和阻尼来使它稳定。然而，对于有某些固定载荷的情况，被控量最终会根据 P 稳定在某个偏离目标量的地方。积分项 I 的引入就是为了消除这种稳态误差。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:1","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"姿态环 将小车当前的倾角作为 PD 控制器的输入，这里注意各参数的符号。小车前倾，我们就向前加速赶一步，后倾就向后加速。但这种控制方法并不稳定，即便参数调试得非常好，最后小车总是加速向一侧倒下。这是因为电机速度具有上限。当小车姿态已经归中但底盘仍有速度时，因为比例部分几乎为零，电机输出一个极小值，产生近似刹车的效果，使得小车快速点头，反而可能产生了比一开始更大的倾角。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:2","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"速度环 为了解决这个问题，我们引入了速度环。速度环以车轮转速为输入，其输出作为姿态环的目标位置输入，即小车有前向的速度时，将姿态环的零位调整到一个后倾的角度，让姿态环多赶一步。姿态环采用 PD，速度环采用 PI. 两套控制参数的调试还是有点麻烦，理想过程是先调姿态 P 到一个不错的响应，再调姿态 D 到能够站立一小会儿，再调速度环。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:3","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"中断引发的故事 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:2:0","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"树莓派 我总觉得 arduino 更像个玩具，买了没啥大用，而树莓派也有 GPIO 口，还是个 Linux PC，怎么看可玩性都更高一些。于是买了个最丐的 2G RAM 4B 进行开发。主要使用 C 语言和 Wiring Pi. 硬件部分淘宝解决，上来先驱动下各个部件： 直流电机 驱动器是常见的 L298N. 简单说就是两个引脚电平调方向，一路 PWM 输出控制电压. PWM 采用树莓派的 pwm0, pwm1 两路硬件 pwm, WiringPi 有对应的函数，非常好写，注意一下引脚号即可。 MPU6050 I2C 协议的六轴陀螺仪加速度计. MPU6050 有内置的运动处理器 DMP，可以直接以四元数的形式输出融合后的姿态，诶！?什么叫融合…直接读不就完了？ 节约主机计算资源，不过不能通过一般的方式驱动，芯片手册里也没有驱动相关的信息。官方提供了 MSP430 上的例程，代码量比较大，核心是要传一串神秘代码来开启 DMP 功能。我找了半天适合树莓派的 dmp 库只发现了这个 C++ 库. 虽说也可以自行移植，但当时我这个小白办不到啊… 唉，在 C++ 里写 C 吧。 编码器 硬件上它产生两路 90° 相位的方波，每转一圈会产生固定数量的跳变。通过读一路跳变时另一路的电平来确定当前旋转方向，往往用中断驱动。真是神奇啊。 WiringPi 包装了方便的函数来让我们注册中断处理函数： int wiringPiISR (int pin, int edgeType, void (*function)(void)) ; 这里只需要传入函数指针，即可在中断发生时调用注册的函数。注意这个函数的返回值和参数都是void, 那么怎么与外界联系呢？答案是使用全局变量： long long COUNT; void myISR(void); void myISR(void){ COUNT++; } int main(void){ wiringPiSetup(); /* Some code */ wiringPiISR(pin, INT_EDGE_BOTH, myISR); /* Some code */ } 这样，每次中断发生时，COUNT 的值都会自增。因为编码器计数非常快，这里把 COUNT 定义为 long long (64 位) 贴一下我的 C 代码，成功驱动了电机和编码器吗？, 还可以在 SSH 中按q退出，可以说距离完成只差控制部分了： motor.h #include \u003cpthread.h\u003e#include \u003cstdbool.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cwiringPi.h\u003e #define PIN_MOTOR1 26 #define PIN_MOTOR1_IN1 6 #define PIN_MOTOR1_IN2 27 #define PIN_MOTOR1_OUT1 28 #define PIN_MOTOR1_OUT2 29 #define PIN_MOTOR2 23 #define PIN_MOTOR2_IN1 22 #define PIN_MOTOR2_IN2 21 #define PIN_MOTOR2_OUT1 24 #define PIN_MOTOR2_OUT2 25 #define START_POWER 120 typedef struct smotor { const short PIN; const short PIN_IN1; const short PIN_IN2; const short PIN_OUT1; const short PIN_OUT2; const short DIR; const void (*run)(); const int (*readSpd)(); long long lastPos; } Motor; int motorInit(void); static void motor(Motor *pmotor, int power); static int readSpd(Motor *); static void readEnc1A(void); static void readEnc1B(void); static void readEnc2A(void); static void readEnc2B(void); Motor leftWheel; Motor rightWheel; motor.c #include \"motor.h\" int motorInit(void) { if (!wiringPiSetup()) { /* set interrupt response */ wiringPiISR(PIN_MOTOR1_OUT1, INT_EDGE_BOTH, \u0026readEnc1A); wiringPiISR(PIN_MOTOR1_OUT2, INT_EDGE_BOTH, \u0026readEnc1B); wiringPiISR(PIN_MOTOR2_OUT1, INT_EDGE_BOTH, \u0026readEnc2A); wiringPiISR(PIN_MOTOR2_OUT2, INT_EDGE_BOTH, \u0026readEnc2B); /* set pin mode */ pinMode(PIN_MOTOR1, PWM_OUTPUT); pinMode(PIN_MOTOR1_IN1, OUTPUT); pinMode(PIN_MOTOR1_IN2, OUTPUT); pinMode(PIN_MOTOR1_OUT1, INPUT); pinMode(PIN_MOTOR1_OUT2, INPUT); pinMode(PIN_MOTOR2, PWM_OUTPUT); pinMode(PIN_MOTOR2_IN1, OUTPUT); pinMode(PIN_MOTOR2_IN2, OUTPUT); pinMode(PIN_MOTOR2_OUT1, INPUT); pinMode(PIN_MOTOR2_OUT2, INPUT); return 0; } else { return -1; }; }; void motor(Motor *pmotor, int power) { digitalWrite(pmotor-\u003ePIN_IN1, ((power * pmotor-\u003eDIR) \u003e 0)); digitalWrite(pmotor-\u003ePIN_IN2, ((power * pmotor-\u003eDIR) \u003c 0)); pwmWrite(pmotor-\u003ePIN, abs(power) + START_POWER); }; int readSpd(Motor *pmotor) { long long pos = pmotor-\u003elastPos; usleep(5000); return (pmotor-\u003elastPos) - pos; }; void readEnc1A(void) { (leftWheel.lastPos) -= leftWheel.DIR * (((digitalRead(PIN_MOTOR1_OUT1) == digitalRead(PIN_MOTOR1_OUT2)) \u003c\u003c 1) - 1); /* equivalent to (motor1.lastPos) += motor1.DIR * ((digitalRead(PIN_MOTOR1_OUT1) == digitalRead(PIN_MOTOR1_OUT2)) ? -1 : 1); */ }; void readEnc1B(void) { (leftWheel.lastPos) += leftWheel.DIR * (((digitalRead(PIN_MOTOR1_OUT1) == digitalRead(PIN_MOTOR1_OUT2)) \u003c\u003c 1) - 1); }; void readEnc2A(void) { (rightWheel.lastPos) -= rightWheel.DIR * (((digitalRead(PIN_MOTOR2_OUT1) == digitalRead(PIN_MOTOR2_OUT2)) \u003c\u003c 1) - 1); }; void readEnc2B(void) { (rightWheel.lastPos) += rightWheel.DIR * (((digitalRead(PIN_MOTOR2_OUT1) == digitalRead(PIN_MOTOR2_OUT2)) \u003c\u003c 1) - 1); }; Motor leftWheel = { PIN_MOTOR1, PIN_MOTOR1_IN1, PIN_MOTOR1_IN2, PIN_MOTOR1_OUT1, PIN_MOTOR1_OUT2, .DIR = 1, motor, readSpd, .lastPos = 0, }; Motor rightWheel = { PIN_MOTOR2, PIN_MOTOR2_IN1, PIN_MOTOR2_IN2, PIN_MOTOR2_OUT1, PIN_MOTOR2_OUT2, .DIR = -1, motor, readSpd, .lastPos = 0, }; main.c #include \"motor.h\"#include \u003cstdio.h\u003e void *usrInterrupt(void *arg); char usrInput = ' '; i","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:2:1","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"Rust 与并发编程 假期短暂，我的第一次尝试以失败告终。之后在网课之余，机缘巧合，我接触到了 Rust 这门语言。简单看了看 the book 发现还不错，于是花了三周多，在网课之余把它看完了。其中 ownership 和 borrow checker 非常特别，它们规定： 对一个变量的引用 (指针), 只能存在： 有且仅有一个独占引用(写者), 且没有共享引用 (读者), 或 没有独占引用 (写着), 任意多个共享引用 (读者) 换句话说，只要有人在写，其他任何读写操作都不能进行。等等，我之前的编码器计数是怎么实现的？违背了这个规范呀！ 一年后的今天，让我们彻底了结这个问题：数据争用. 我用的 Raspbian 是 32 位版本，其 long long 被定义为 64 位有符号整型。换句话说，绝大部分对 64 位整数的操作都不能在一条汇编指令中完成。因此，当测速线程修改了速度变量却还没完成时，有可能被调度打断 (raspbian 并不是实时系统). 此时读取这个变量就会发生数据争用的问题。至于 C 代码为什么没问题，是因为仅仅打印了编码器计数，而没有另起一个测速线程。中断处理速度极快且不会被其他线程抢占，而中断发生的频率又没有高到能够常常打断主线程中的读取过程。我翻 makefile 才发现我 C 开了 O3, C++ 啥优化也没开… 那么，合理的解决办法是什么呢？ 原子操作 atom 是不可分的意思，原子操作就是不会被打断的操作。缺点是需要处理器支持，且一般只能操作长度不大于处理器字长的数据类型。关于 Ordering 的选择，如果只需要原子性，使用 Ordering::Relax 即可，用于计数的话再适合不过了。在多核情况下还需要考虑内存一致性来选择 Ordering, 最严格的一般是 Ordering::SeqCst. 互斥锁\\读写锁 (普通线程) 对于有操作系统 (包括实时系统) 情况下普通线程间的资源共享，可以使用这两种锁。详见 the book. 如果获取锁失败，线程可以选择出让控制权让操作系统先调度其他线程。 临界区 (中断) 由于中断总能抢占当前线程，除非你允许中断处理函数在资源被占用的情况下漏掉中断不处理，否则主线程中的锁形同虚设。有的处理器可以暂时关闭所有中断，这样当前正在执行的任务就不会被打断。如果使用 rust，还需要配合 Mutex, RefCell 等来通过语法检查，详见 the embedded rust book. 缓冲区 还有一种取巧的做法，使用内存来通信。环形缓冲区可以实现为数组 + 头尾原子指针，我们可以让发送端独占头指针，接收端独占尾指针，每次发送/接收，都向内存中写入/读取数据后操作指针自增。只要缓冲区够大且接收端处理速度大于发送端发送速度，一般不会漏掉消息。保险起见还可以在发送和/或接收时加上头尾指针判断 如果现在让我重新设计树莓派编码器测速逻辑：我会使用中断操作原子类型计数，用互斥锁包装速度全局变量，让测速线程和主线程抢锁，来保证对速度变量的操作不会产生竟态条件。 不过，后来实习接触了 STM32 这样的单片机，拿来做平衡小车足够了，反观树莓派 4B 还需要 5V3A 供电，我还特意买了微雪的电池扩展版，头顶两节 18650 简直不要太笨重，于是树莓派就光荣的吃灰了. STM32 的定时器具有编码器功能，可以通过每次读取后清零的方法获取速度，配合定时器中断测速即可。不过我用 rust 实现的版本因为软件 I2C 的库必须要一个定时器，导致没定时器拿来做中断了… 只好用延时实现。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:2:2","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"多传感器融合 还记得 MPU6050 有个 DMP 库吗？后来转向 Rust + STM32 后，因为没找到能用的 DMP 库，我就用的六轴原始数据。确定角度还不简单？三轴加速度和重力一比较就完事儿了，我用的库还有现成的包装 get_acc_angles(\u0026mut self) -\u003e Result\u003cVector2, Mpu6050Error\u003e. 快快拿来一试，再加上现成的 PID 库, P 输入用刚才获得的角度，D 输入直接用陀螺仪，不到一个小时代码就编译通过了。不得不说，Rust 这点真的香: 99% 的情况下能过编译就能跑. 小车拿在手里，前倾就向前加速，后倾就向后加速，各参数极性正确！但是 PID 参数我竟然调了三天都没调明白…连最基本的姿态环都几乎无法实现。最好的一组参数也只能维持个 10 秒钟左右。我干脆两手捏住轮子当成纯倒立摆，诶！?怎么这都稳定不了？看了输出才发现，获取到的角度抖动太大！那就加平滑滤波！可加了滤波也没法稳定，这让我又犯了难… 想想也是，这小车本身就在抖动，读出来的加速度可不仅仅是重力加速度。那要怎么确定角度呢？有以下几种办法： ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:3:0","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"互补滤波 $$ \\theta = k \\cdot \\theta_{\\text{acc}} + (1-k)\\cdot \\int{{\\omega}dt} $$ 通过对读取到的角速度 $\\omega$ 积分，我们也可以得到一个角度数据 $\\theta_\\text{gyro}$. 当然这个数据会因为累加存在一定的误差。之前提到从加速度计和重力方向也可以得到一个角度数据 $\\theta_\\text{acc}$, 我们把两个数据分辨乘以一定的权重后相加，作为上述控制系统的输入。在实际实现时，往往采用递推的方式将其改写为： $$ \\theta_{i+1} = k \\cdot \\theta_{\\text{acc}} + (1-k)\\cdot ({\\theta_{i} + \\omega dt}) $$ 还可以根据当前两个数据的大小来动态调整权重，比如：当加速度计测到一个较大数据时，更相信陀螺仪。当陀螺仪数据很小时，更相信加速度计。 本来想用 Rust 在 STM32 上实现互补滤波的，但因为之前提到的定时器不够只能在 main 函数中 delay 测速来完成整个控制循环，实践发现这个延时并不稳定，导致陀螺仪积分要乘的 $dt$ 不好确定。最后还是决定转回 C，有 DMP 不用，何苦呢。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:3:1","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"卡尔曼滤波 久仰卡尔曼滤波大名，可惜我水平不够还没看明白原理… 如果有现成的库可以使用，自然是拿来主义。我尝试了 rust 的 adskalman, 但因为编译出的二进制太大没能成功烧录。 关于卡尔曼滤波的原理，希望自己以后可以补充完全。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:3:2","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"总结 最后用 C 和 DMP 完成的版本效果如下。时间紧张，代码质量太差，就不献丑了。 平衡小车，搞明白原理其实并不难。如果我一上来就选了 arduino，或许就不会接触到 Rust 和 STM32. 从树莓派一路踩坑下来，反倒收获了更多的知识和经验。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:4:0","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"这段时间在实习和个人项目中学习 STM32 上嵌入式 Rust 的一些总结 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:0:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"资料 The Book: 熟悉 Rust 语法，其中并发部分的 channel 和 Mutex, Cell, RefCell 等，在嵌入式中有类似的用法 Discovery: 写博客时发现这本书有了使用 micro:bit 的新版, 我读的是使用 STM32F3Discovery 的旧版 The Embedded Rust Book: 有嵌入式开发经验可以跳过 discovery 直接看这本。我买了 F3 板子所以直接跑在板子上没有用 QEMU RTIC: 一个裸机多任务框架，更好地共享 Rust 变量。我看的时候是 v0.5，现在已经出到 1.0 了，可喜可贺。 ferrous-systems’s blog: 这家公司的博客介绍了许多 Rust 在嵌入式开发中的技巧，获益匪浅。尤其是实现了一个 async/await executor ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:1:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"环境搭建 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"Rust 工具链 这里使用 rustup 安装了 msvc 工具链的 rust 按需下载对应平台的 core，否则无法编译： rustup target add thumbv6m-none-eabi # Cortex-M0 and Cortex-M0+ rustup target add thumbv7m-none-eabi # Cortex-M3 rustup target add thumbv7em-none-eabi # Cortex-M4 and Cortex-M7 (no FPU) rustup target add thumbv7em-none-eabihf # Cortex-M4F and Cortex-M7F (with FPU) ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:1","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"调试工具 我使用包管理器 scoop, 以下工具scoop install 即可 arm-none-eabi-gdb openocd 此外，如果使用 ST-LINK，需要手动安装驱动 这篇文章末尾提供了使用 vscode 调试的方法，我觉得 gdb 命令行就够用了，因此没有尝试 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:2","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"Hello World 仅限 cortex-m 内核，其他平台未研究 cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart 修改 .cargo/config.toml 修改 memory.x 一般 STM32 FLASH 起始地址在 0x08000000, RAM 在 0x20000000. 芯片手册里如果有多段 RAM，取第一段的大小 修改 openocd.cfg，可用的配置文件可以在 openocd 的安装目录下找到 在项目目录下执行openocd, 不要关闭这个终端 另起一个终端，执行cargo run, 观察是否收到输出 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:3:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"PAC \u0026 HAL PACPeripheral Access Crate 一般由 svd2rust 根据 ARM 厂商提供的 SVDCMSIS System View Description 文件自动生成，提供了寄存器操作的基本包装，API 用法如： pwm.ctl.modify(|r,w|w.globalsync0().clear_bit()); HALHardware Abstract Layer 在 PAC 基础上遵循 embedded-hal 编写。但至少 STM32 各系列的实现略有区别，导致同样的外设在 f1, f4 系列上的代码可能大不一样，各芯片的 driver crate 也不一定都能使用。部分外设如 FSMC，因为 hal 没有编写相关部分，几乎只能靠手动配置寄存器并引入 unsafe 块才能使用 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:4:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"起手式 (裸机) #![no_main]/* main 使用 entry 宏引入 */#![no_std]/* 不使用 std 因为不可用 */usepanic_semihostingas_;/* 选择 panic 处理方式，不接调试器 semihosting 会卡死 */// use panic_halt as _; // use panic_abort as _; /* 需要 nightly 工具链 */ // use cortex_m::asm; /* 如果需要直接使用汇编指令 */ usecortex_m_rt::entry;// use cortex_m_semihosting::hprintln; /* semihosting 下的 println！宏，方便调试 */ // use core::fmt::Write; /* 如果使用串口调试，使用 write！宏向串口 tx 输出 */ usehal::{delay::Delay,/* 常用的延时 */pac,/* hal 包装过的 pac */prelude::*,};usestm32f1xx_halashal;/* 导入一个 hal */#[entry]fn main()-\u003e !{let(dp,cp)=(/* dp:device peripherals，指 MCU 厂商扩展的外设 */pac::Peripherals::take().unwrap(),/* cp: core peripherals，指 ARM 自带的外设 */cortex_m::Peripherals::take().unwrap(),);/* 配置时钟 */let(mutflash,mutrcc)=(dp.FLASH.constrain(),dp.RCC.constrain());letclocks=rcc.cfgr.use_hse(8.mhz()).freeze(\u0026mutflash.acr);/* 初始化 delay 对象，这里用系统时钟 SYST */letmutdelay=Delay::new(cp.SYST,clocks);/* gpio 抽象，各 hal 略有不同 */let(mutgpioa,mutgpiob)=(dp.GPIOA.split(\u0026mutrcc.apb2),dp.GPIOB.split(\u0026mutrcc.apb2));loop{/* do something */}}``` ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:5:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"safe 全局变量 我们都知道操作 static mut 是 unsafe 的，大量的编程规范要求尽量减少使用全局变量。但嵌入式环境下往往无法避免。一个更好的方法是规划好变量的作用范围后使用 RTIC. 不过这里先讲一下简单的做法和原理 Atomic 是平台支持下最优雅的做法，简洁，安全。缺点是不能进行有复杂逻辑的操作，且仅支持几种基本数据类型，不过一般需求下够用了。 Mutex\u003cRefCell\u003cT\u003e\u003e 配合临界区使用。需要use cortex_m::interrupt::{self, Mutex};. 可以包装更复杂的数据类型，包括外设。但会引入大量语法噪音。使用方法大致为： 声明一个 static FOO:Mutex\u003cRefCell\u003cOption\u003cT\u003e\u003e\u003e = Mutex::new(RefCell::new(None)); 在 main 中初始化外设并在临界区中使用 interrupt::free(|cs| FOO.borrow(cs).replace(Some(T))); 移动所有权给全局变量 FOO 使用时同样需要进入临界区后，使用 FOO.borrow(cs).borrow() 获取RefCell后再 as_ref() 才能得到内部的 T 我几乎从不使用这种方法，心累手也累，复杂项目直接上 RTIC 完事儿 这部分相当让人抓狂，许多在 C 语言中可以直接写的部分要包上好多层，即便我知道它是安全的。 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:6:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"RTIC 我很想管 RTIC 叫抢占式调度框架，如果搭配内存分配器，用起来和抢占式的 RTOS 没啥区别。然而它其实只是个前后台系统，靠设置中断优先级来管理任务，并不具有上下文切换的能力。用它的原因就在于它包装了上述复杂的 Mutex\u003cRefCell\u003cOption\u003cT\u003e\u003e\u003e, 并可以将空闲的硬中断注册为可以有参数和容量的多个软中断。 然而，缺点来自于它使用了大量的宏，导致无论 RLSRust Language Server 还是 RARust Analyzer 都不能很好的支持自动补全和类型。有些报错会一直显示却不影响正常编译… 真正编不过时又找不到报错的原因。因此我经常先在裸机上搭好一些外设驱动框架，调试好类型后再复制进 RTIC 项目。 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:7:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"内存分配器 alloc-cortex-m: 需要 nightly 工具链，用法 使用内存分配器后，可以像有 std 一样使用方便地使用 vec! 等。可以先通过 FSMC 配置好外部 RAM 后将其内存起始地址指向 RAM ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:8:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"RTOS 我尝试过drone, WSL 和 Linux 物理机都试过，然而连 hello world 都没能跑起来… 它似乎也没在更新了 另外还有Tock OS, 但外设驱动需要自行编写，官方的 ST demo 只有 f3disco 和两个 f4nucleo，并没有尝试过 RTOS 方面估计很难超越 μCOS 和 FreeRTOS，大量芯片驱动都有现成的 C 代码，Rust 这边还只能用爱发电. OS 能否和现有的 hal 框架兼容还是个问题 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:9:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"常用 crate heapless: 提供了静态内存分配的常用数据类型 HistoryBuffer: 可用于平滑滤波 spsc::Queue: 消息队列 String: 方便输出调试信息 bitbang-hal: 提供了软件模拟的 I2C, USART, SPI nb: 虽然名字叫做 non-block 但更多用 block！宏来等待外设工作完成，例如： block!(Serial.write(byte))?; micromath: 提供了嵌入式环境下可能缺失的某些 F32 操作 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:10:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"总结 个人项目的话，Embedded Rust 只能说差强人意。小芯片 debug 编译二进制太大，没法调试。语法噪音也是相当烦人。我利用几个芯片的 crate 写了个平衡车玩，过段时间会专门介绍 实习中用 rust 写了一些小板子的验证 demo，逻辑简单的话用 hal 分分钟就能起个项目。也用 RTIC 尝试过复杂项目，有这么几个问题： 本质仍然是前后台，复杂任务调度比较烧脑 运行速度比 μCOSⅢ 慢不少，写了个简单的串口环回，能慢将近一半。或许是我时钟没配好…也可能人家商业公司在关中断这块儿确实优化的好。尝试了两天，还是改用 μCOS 了，因为即便我这个实习生写出来也以后没人接手维护… Rust 合理的 trait 抽象加上 embedded-hal 这套统一的规范，使得各种库的编写成为可能。我的平衡车项目几乎纯靠调库就能完成，可见这套抽象的威力。这也是 STM32 的标准库和 HAL 库 之所以火遍中国。然而现实很骨感，一是性能损失，这种抽象多少会带来一些冗余代码，当然 LLVM 能不能优化我就不懂了; 二是虽然有 embedded-hal 规定了一些 trait，但 trait 之外的部分各不相同，就比如 ST 系列，FSMC 几乎没有，F1XXHAL 和 F4XXHAL 许多 api 完全不同… 最后一点纯属猜测，C++ 也有虚函数，也完全可以定义一套接口规范，为何 ARM 厂商不用 C++ 呢？虚表实现有性能损失，那编译器也可以用其他实现呀，反正芯片厂的编译器都是魔改过的…这么多年 C++ 都没在嵌入式铺开，Rust 只能说悬 Rust 是个好语言，但在嵌入式方面生态似乎是更主要的问题。没有解决大痛点的话业界根本没有动力抛弃多年积累重新开始。 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:11:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["misc"],"content":"记录一下我的博客历程 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:0:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Notion 搞一个博客的想法由来已久，2017 年接触到 notion，文章可以开启外链，当博客用完全没问题。然而国内访问不稳定，以及——不好看，于是迟迟没有动手。目前主要把 notion 的 database 作为跨平台收藏夹、偶尔写一些较重的 todo list 便于跨平台访问。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:1:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Pelican 2019 年大一期间找点事做，接触到 Github Pages 与静态博客工具，因为相对熟悉 Python 选择了 Pelican。断断续续开发到 2020 年暑假结束，接触了很多前端知识。最后的效果差强人意，虽然确实部署了一两篇文章，但总因为外观不舒心而没有动力更新。在此期间了解了 Hexo Next1, Hugo Meme2 等等基于其他博客平台的主题，确定了自己期望的几个主要功能： dark mode：以前常驻深色模式，但宿舍采光很好，导致白天只能调高亮度用白色模式，夜晚只能调低亮度用深色模式，否则眼睛难受。我的博客自然也应具备这个功能。实现上就是用 js 做两套 css 的切换。具体到深色模式的配色设计，又有很多细节，以及 svg 的适配等等，也是个小坑。 responsive：适配移动端，本质上是 css 的 media 属性。折叠菜单等又需要 js 配合。 toctable of contents：Meme2 可以说满足 99% 的需求，除了没有侧边目录，导致只能线性阅读。更适合杂文而非技术类博客。 一个好看的顶栏，起码 sticky 定位 $\\LaTeX$：KaTeX 或 MathJax markdown 扩展语法 中文：一个好看的中文字体，Meme2 所用的 思源宋体Noto Serif SC 真是太棒了 图片：支持图片下方标注，合理的缩放 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:2:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Hugo ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Meme2 如同上文所述，尝试拼一个侧边目录进去，技术力不够调不好看，作罢。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:1","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Eureka 这个主题的 doc 模式启发了另一种组织文章的方式。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:2","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"LoveIt 相当惊艳的主题，功能丰富，完成度高。看到之后别无所求了。然而似乎没有再更新了，有意向转向 DoIt，不过先把 LoveIt 折腾明白吧。 https://github.com/iissnan/hexo-theme-next ↩︎ https://io-oi.me 他的文章也很有意思 ↩︎ ↩︎ ↩︎ ↩︎ ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:3","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"}]