[{"categories":["tech"],"content":"这段时间在实习和个人项目中学习 STM32 上嵌入式 Rust 的一些总结 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:0:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"资料 The Book: 熟悉 Rust 语法, 其中并发部分的 channel 和 Mutex, Cell, RefCell 等, 在嵌入式中有类似的用法 Discovery: 写博客时发现这本书有了使用 micro:bit 的新版, 我读的是使用 STM32F3Discovery 的旧版 The Embedded Rust Book: 有嵌入式开发经验可以跳过 discovery 直接看这本. 我买了 F3 板子所以直接跑在板子上没有用 QEMU RTIC: 一个裸机多任务框架, 更好地共享 Rust 变量. 我看的时候是 v0.5, 现在已经出到 1.0 了, 可喜可贺. ferrous-systems’s blog: 这家公司的博客介绍了许多 Rust 在嵌入式开发中的技巧, 获益匪浅. 尤其是实现了一个 async/await executor ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:1:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"环境搭建 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"Rust 工具链 这里使用 rustup 安装了 msvc 工具链的 rust 按需下载对应平台的 core, 否则无法编译: rustup target add thumbv6m-none-eabi # Cortex-M0 and Cortex-M0+ rustup target add thumbv7m-none-eabi # Cortex-M3 rustup target add thumbv7em-none-eabi # Cortex-M4 and Cortex-M7 (no FPU) rustup target add thumbv7em-none-eabihf # Cortex-M4F and Cortex-M7F (with FPU) ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:1","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"调试工具 我使用包管理器 scoop, 以下工具scoop install 即可 arm-none-eabi-gdb openocd 此外,如果使用 ST-LINK, 需要手动安装驱动 这篇文章末尾提供了使用 vscode 调试的方法, 我觉得 gdb 命令行就够用了, 因此没有尝试 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:2","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"Hello World 仅限 cortex-m 内核, 其他平台未研究 cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart 修改 .cargo/config.toml 修改 memory.x 一般 STM32 FLASH 起始地址在 0x08000000, RAM 在 0x20000000. 芯片手册里如果有多段 RAM, 取第一段的大小 修改 openocd.cfg, 可用的配置文件可以在 openocd 的安装目录下找到 在项目目录下执行openocd, 不要关闭这个终端 另起一个终端,执行cargo run, 观察是否收到输出 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:3:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"PAC \u0026 HAL PACPeripheral Access Crate 一般由 svd2rust 根据 ARM 厂商提供的SVDCMSIS System View Description文件自动生成, 提供了寄存器操作的基本包装, API 用法如: pwm.ctl.modify(|r,w|w.globalsync0().clear_bit()); HALHardware Abstract Layer 在 PAC 基础上遵循 embedded-hal 编写. 但至少 STM32 各系列的实现程度并不高, 并且进度各不相同, 导致同样的外设在 f1, f4 系列上的代码可能大不一样, 各芯片的 driver crate 也不一定都能使用. 部分外设如 FSMC, 因为 hal 没有编写相关部分, 几乎只能靠手动配置寄存器并引入 unsafe 块才能使用 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:4:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"起手式(裸机) #![no_main]/* main使用entry宏引入 */#![no_std]/* 不使用std因为不可用 */usepanic_semihostingas_;/* 选择panic处理方式, 不接调试器semihosting会卡死 */// use panic_halt as _; // use panic_abort as _; /* 需要nightly工具链 */ // use cortex_m::asm; /* 如果需要直接使用汇编指令 */ usecortex_m_rt::entry;// use cortex_m_semihosting::hprintln; /* semihosting下的println!宏, 方便调试 */ // use core::fmt::Write; /* 如果使用串口调试, 使用write!宏向串口tx输出 */ usehal::{delay::Delay,/* 常用的延时 */pac,/* hal包装过的pac */prelude::*,};usestm32f1xx_halashal;/* 导入一个hal */#[entry]fn main()-\u003e !{let(dp,cp)=(/* dp:device peripherals, 指MCU厂商扩展的外设 */pac::Peripherals::take().unwrap(),/* cp: core peripherals, 指ARM自带的外设 */cortex_m::Peripherals::take().unwrap(),);/* 配置时钟 */let(mutflash,mutrcc)=(dp.FLASH.constrain(),dp.RCC.constrain());letclocks=rcc.cfgr.use_hse(8.mhz()).freeze(\u0026mutflash.acr);/* 初始化delay对象, 这里用系统时钟SYST */letmutdelay=Delay::new(cp.SYST,clocks);/* gpio抽象, 各hal略有不同 */let(mutgpioa,mutgpiob)=(dp.GPIOA.split(\u0026mutrcc.apb2),dp.GPIOB.split(\u0026mutrcc.apb2));loop{/* do something */}}``` ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:5:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"safe 全局变量 我们都知道操作 static mut 是 unsafe 的, 大量的编程规范要求尽量减少使用全局变量. 但嵌入式环境下往往无法避免. 一个更好的方法是规划好变量的作用范围后使用 RTIC. 不过这里先讲一下简单的做法和原理 Atomic 是平台支持下最优雅的做法, 简洁, 安全. 缺点是不能进行有复杂逻辑的操作, 且仅支持几种基本数据类型, 不过一般需求下够用了. Mutex\u003cRefCell\u003cT\u003e\u003e 配合临界区使用. 需要use cortex_m::interrupt::{self, Mutex};. 可以包装更复杂的数据类型, 包括外设. 但会引入大量语法噪音. 使用方法大致为: 声明一个 static FOO:Mutex\u003cRefCell\u003cOption\u003cT\u003e\u003e\u003e = Mutex::new(RefCell::new(None)); 在 main 中初始化外设并在临界区中使用 interrupt::free(|cs| FOO.borrow(cs).replace(Some(T))); 移动所有权给全局变量 FOO 使用时同样需要进入临界区后, 使用 FOO.borrow(cs).borrow() 获取RefCell后再 as_ref() 才能得到内部的 T 我几乎从不使用这种方法, 心累手也累, 复杂项目直接上 RTIC 完事儿 这部分相当让人抓狂, 许多在 C 语言中可以直接写的部分要包上好多层, 即便我知道它是安全的. ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:6:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"RTIC 我很想管 RTIC 叫抢占式调度框架, 如果搭配内存分配器, 用起来和抢占式的 rtos 没啥区别. 然而它其实只是个前后台系统, 靠设置中断优先级来管理任务, 并不具有上下文切换的能力. 用它的原因就在于它包装了上述复杂的 Mutex\u003cRefCell\u003cOption\u003cT\u003e\u003e\u003e, 并可以将空闲的硬中断注册为可以有参数和容量的多个软中断. 然而, 缺点来自于它使用了大量的宏, 导致无论 RLS 还是 RA 都不能很好的支持自动补全和类型. 有些报错会一直显示却不影响正常编译… 真正编不过时又找不到报错的原因. 因此我经常先在裸机上搭好一些外设驱动框架, 调试好类型后再复制进 RTIC 项目. ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:7:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"内存分配器 alloc-cortex-m: 需要 nightly 工具链, 用法 使用内存分配器后, 可以像有 std 一样使用方便地使用 vec! 等. 可以先通过 FSMC 配置好外部 RAM 后将其内存起始地址指向 RAM ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:8:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"RTOS 我尝试过drone, WSL 和 Linux 物理机都试过, 然而连 hello world 都没能跑起来… 它似乎也没在更新了 另外还有Tock OS, 但外设驱动需要自行编写, 官方的 ST demo 只有 f3disco 和两个 f4nucleo, 并没有尝试过 RTOS 方面估计很难超越 μCOS 和 FreeRTOS, 大量芯片驱动都有现成的 C 代码, Rust 这边还只能用爱发电. OS 能否和现有的 hal 框架兼容还是个问题 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:9:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"常用 crate heapless: 提供了静态内存分配的常用数据类型 HistoryBuffer: 可用于平滑滤波 spsc::Queue: 消息队列 String:: 方便输出调试信息 bitbang-hal: 提供了软件模拟的 I2C, USART, SPI nb: 虽然名字叫做 non-block 但更多用 block!宏来等待外设工作完成, 例如: block!(Serial.write(byte))?; micromath: 提供了嵌入式环境下可能缺失的某些 F32 操作 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:10:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"总结 个人项目的话, Embedded Rust 只能说差强人意. 小芯片 debug 编译二进制太大, 没法调试. 语法噪音也是相当烦人. 我利用几个芯片的 crate 写了个平衡车玩, 过段时间会专门介绍 实习中用 rust 写了一些小板子的验证 demo, 逻辑简单的话用 hal 分分钟就能起个项目. 也用 RTIC 尝试过复杂项目, 有这么几个问题: 本质仍然是前后台, 复杂任务调度比较烧脑 运行速度比 μCOSⅢ 慢不少, 写了个简单的串口环回, 能慢将近一半. 或许是我时钟没配好…也可能人家商业公司在关中断这块儿确实优化的好. 尝试了两天, 还是改用 μCOS 了, 因为即便我这个实习生写出来也以后没人接手维护… ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:11:0","tags":null,"title":"初探嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["misc"],"content":"记录一下我的博客历程 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:0:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Notion 搞一个博客的想法由来已久，2017 年接触到 notion，文章可以开启外链，当博客用完全没问题。然而国内访问不稳定，以及——不好看，于是迟迟没有动手。目前主要把 notion 的 database 作为跨平台收藏夹、偶尔写一些较重的 todo list 便于跨平台访问。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:1:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Pelican 2019 年大一期间找点事做，接触到 Github Pages 与静态博客工具，因为相对熟悉 Python 选择了 Pelican。断断续续开发到 2020 年暑假结束，接触了很多前端知识。最后的效果差强人意，虽然确实部署了一两篇文章，但总因为外观不舒心而没有动力更新。在此期间了解了 Hexo Next1, Hugo Meme2等等基于其他博客平台的主题，确定了自己期望的几个主要功能： dark mode：以前常驻深色模式，但宿舍采光很好，导致白天只能调高亮度用白色模式，夜晚只能调低亮度用深色模式，否则眼睛难受。我的博客自然也应具备这个功能。实现上就是用 js 做两套 css 的切换。具体到深色模式的配色设计，又有很多细节，以及 svg 的适配等等，也是个小坑。 responsive：适配移动端，本质上是 css 的 media 属性。折叠菜单等又需要 js 配合。 toc：Meme2可以说满足 99% 的需求，除了没有侧边目录，导致只能线性阅读。更适合杂文而非技术类博客。 一个好看的顶栏，起码 sticky 定位 $\\LaTeX$：KaTeX 或 MathJax markdown 扩展语法 中文：一个好看的中文字体，Meme2所用的思源宋体Noto Serif SC真是太棒了 图片：支持图片下方标注，合理的缩放 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:2:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Hugo ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Meme2 如同上文所述，尝试拼一个侧边目录进去，技术力不够调不好看，作罢。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:1","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Eureka 换到 Hugo 之后并没有像 Pelican 一样深入了解。这个主题的 doc 模式启发了另一种组织文章的方式。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:2","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"LoveIt 相当惊艳的主题，功能丰富，完成度高。看到之后别无所求了。然而似乎没有再更新了，有意向转向 DoIt，不过先把 LoveIt 折腾明白吧。 https://github.com/iissnan/hexo-theme-next ↩︎ https://io-oi.me 他的文章也很有意思 ↩︎ ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:3","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"}]