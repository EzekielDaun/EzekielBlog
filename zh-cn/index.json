[{"categories":["tech"],"content":"大三才做出来平衡小车实在是太菜了…分享一下过程和学习笔记. 写这篇时还没有学过任何控制相关的课程, 如有错误请见谅 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:0:0","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"平衡小车 PID 原理 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:0","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"PID 网上有太多 PID 解析了, 这里不多赘述, 讲一下我的理解 小时候一定拨过钢尺, 振幅越来越小最后不振了. 能来回振是因为钢尺有弹性, 能停下是因为有阻尼. 弹簧 + 阻尼一般能解决大部分问题, 而这其实就是 PD 控制器. 二阶线性微分方程从原理上解释了这一切. 忘光了现学的… $$ my''+cy'+ky=f(t) $$ 用 RLC 电路理解也可以 假设这些参量均大于零, 即特征方程的解$r_1 , r_2$的实部$\\frac{-c}{2m}$小于零, 则微分方程的通解$y=K_1 e^{r_1 t} + K_2 e^{r_2 t}$一定收敛. 理想情况是临界阻尼$r_1 = r_2$, 此时通解为$y=Ke^{rt} + Kte^{rt}$ 因此, PD 控制器可以理解为给原本的模型套上了弹簧和阻尼来使它稳定. 然而, 对于有某些固定载荷的情况, 被控量最终会根据 P 稳定在某个偏离目标量的地方. 积分项 I 的引入就是为了消除这种稳态误差. ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:1","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"姿态环 将小车当前的倾角作为 PD 控制器的输入, 这里注意各参数的符号. 小车前倾, 我们就向前加速赶一步, 后倾就向后加速. 但这种控制方法并不稳定, 即便参数调试得非常好, 最后小车总是加速向一侧倒下. 这是因为电机速度具有上限. 当小车姿态已经归中但底盘仍有速度时, 因为比例部分几乎为零, 电机输出一个极小值, 产生近似刹车的效果, 使得小车快速点头, 反而可能产生了比一开始更大的倾角. ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:2","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"速度环 为了解决这个问题, 我们引入了速度环. 速度环以车轮转速为输入, 其输出作为姿态环的目标位置输入, 即小车有前向的速度时, 将姿态环的零位调整到一个后倾的角度, 让姿态环多赶一步. 姿态环采用 PD, 速度环采用 PI. 两套控制参数的调试还是有点麻烦, 理想过程是先调姿态 P 到一个不错的响应, 再调姿态 D 到能够站立一小会儿, 再调速度环. ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:3","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"中断引发的故事 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:2:0","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"树莓派 我总觉得 arduino 更像个玩具, 买了没啥大用, 而树莓派也有 GPIO 口, 还是个 Linux PC, 怎么看可玩性都更高一些. 于是买了个最丐的 2G RAM 4B 进行开发. 主要使用 C 语言和 Wiring Pi. 硬件部分淘宝解决, 上来先驱动下各个部件: 直流电机 驱动器是常见的 L298N. 简单说就是两个引脚电平调方向, 一路 PWM 输出控制电压. PWM 采用树莓派的 pwm0, pwm1 两路硬件 pwm, WiringPi 有对应的函数, 非常好写, 注意一下引脚号即可. MPU6050 I2C 协议的六轴陀螺仪加速度计. MPU6050 有内置的运动处理器 DMP, 可以直接以四元数的形式输出融合后的姿态,诶!?什么叫融合…直接读不就完了? 节约主机计算资源, 不过不能通过一般的方式驱动, 芯片手册里也没有驱动相关的信息. 官方提供了 MSP430 上的例程, 代码量比较大, 核心是要传一串神秘代码来开启 DMP 功能. 我找了半天适合树莓派的 dmp 库只发现了这个 C++ 库. 虽说也可以自行移植, 但当时我这个小白办不到啊… 唉, 在 C++ 里写 C 吧. 编码器 硬件上它产生两路 90° 相位的方波, 每转一圈会产生固定数量的跳变. 通过读一路跳变时另一路的电平来确定当前旋转方向, 往往用中断驱动. 真是神奇啊. WiringPi 包装了方便的函数来让我们注册中断处理函数: int wiringPiISR (int pin, int edgeType, void (*function)(void)) ; 这里只需要传入函数指针, 即可在中断发生时调用注册的函数. 注意这个函数的返回值和参数都是void, 那么怎么与外界联系呢? 答案是使用全局变量: long long COUNT; void myISR(void); void myISR(void){ COUNT++; } int main(void){ wiringPiSetup(); /* Some code */ wiringPiISR(pin, INT_EDGE_BOTH, myISR); /* Some code */ } 这样, 每次中断发生时, COUNT 的值都会自增. 因为编码器计数非常快, 这里把 COUNT 定义为 long long (64 位) 贴一下我的 C 代码, 成功驱动了电机和编码器吗?, 还可以在 SSH 中按q退出, 可以说距离完成只差控制部分了: motor.h #include \u003cpthread.h\u003e#include \u003cstdbool.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cwiringPi.h\u003e #define PIN_MOTOR1 26 #define PIN_MOTOR1_IN1 6 #define PIN_MOTOR1_IN2 27 #define PIN_MOTOR1_OUT1 28 #define PIN_MOTOR1_OUT2 29 #define PIN_MOTOR2 23 #define PIN_MOTOR2_IN1 22 #define PIN_MOTOR2_IN2 21 #define PIN_MOTOR2_OUT1 24 #define PIN_MOTOR2_OUT2 25 #define START_POWER 120 typedef struct smotor { const short PIN; const short PIN_IN1; const short PIN_IN2; const short PIN_OUT1; const short PIN_OUT2; const short DIR; const void (*run)(); const int (*readSpd)(); long long lastPos; } Motor; int motorInit(void); static void motor(Motor *pmotor, int power); static int readSpd(Motor *); static void readEnc1A(void); static void readEnc1B(void); static void readEnc2A(void); static void readEnc2B(void); Motor leftWheel; Motor rightWheel; motor.c #include \"motor.h\" int motorInit(void) { if (!wiringPiSetup()) { /* set interrupt response */ wiringPiISR(PIN_MOTOR1_OUT1, INT_EDGE_BOTH, \u0026readEnc1A); wiringPiISR(PIN_MOTOR1_OUT2, INT_EDGE_BOTH, \u0026readEnc1B); wiringPiISR(PIN_MOTOR2_OUT1, INT_EDGE_BOTH, \u0026readEnc2A); wiringPiISR(PIN_MOTOR2_OUT2, INT_EDGE_BOTH, \u0026readEnc2B); /* set pin mode */ pinMode(PIN_MOTOR1, PWM_OUTPUT); pinMode(PIN_MOTOR1_IN1, OUTPUT); pinMode(PIN_MOTOR1_IN2, OUTPUT); pinMode(PIN_MOTOR1_OUT1, INPUT); pinMode(PIN_MOTOR1_OUT2, INPUT); pinMode(PIN_MOTOR2, PWM_OUTPUT); pinMode(PIN_MOTOR2_IN1, OUTPUT); pinMode(PIN_MOTOR2_IN2, OUTPUT); pinMode(PIN_MOTOR2_OUT1, INPUT); pinMode(PIN_MOTOR2_OUT2, INPUT); return 0; } else { return -1; }; }; void motor(Motor *pmotor, int power) { digitalWrite(pmotor-\u003ePIN_IN1, ((power * pmotor-\u003eDIR) \u003e 0)); digitalWrite(pmotor-\u003ePIN_IN2, ((power * pmotor-\u003eDIR) \u003c 0)); pwmWrite(pmotor-\u003ePIN, abs(power) + START_POWER); }; int readSpd(Motor *pmotor) { long long pos = pmotor-\u003elastPos; usleep(5000); return (pmotor-\u003elastPos) - pos; }; void readEnc1A(void) { (leftWheel.lastPos) -= leftWheel.DIR * (((digitalRead(PIN_MOTOR1_OUT1) == digitalRead(PIN_MOTOR1_OUT2)) \u003c\u003c 1) - 1); /* equivalent to (motor1.lastPos) += motor1.DIR * ((digitalRead(PIN_MOTOR1_OUT1) == digitalRead(PIN_MOTOR1_OUT2)) ? -1 : 1); */ }; void readEnc1B(void) { (leftWheel.lastPos) += leftWheel.DIR * (((digitalRead(PIN_MOTOR1_OUT1) == digitalRead(PIN_MOTOR1_OUT2)) \u003c\u003c 1) - 1); }; void readEnc2A(void) { (rightWheel.lastPos) -= rightWheel.DIR * (((digitalRead(PIN_MOTOR2_OUT1) == digitalRead(PIN_MOTOR2_OUT2)) \u003c\u003c 1) - 1); }; void readEnc2B(void) { (rightWheel.lastPos) += rightWheel.DIR * (((digitalRead(PIN_MOTOR2_OUT1) == digitalRead(PIN_MOTOR2_OUT2)) \u003c\u003c 1) - 1); }; Motor leftWheel = { PIN_MOTOR1, PIN_MOTOR1_IN1, PIN_MOTOR1_IN2, PIN_MOTOR1_OUT1, PIN_MOTOR1_OUT2, .DIR = 1, motor, readSpd, .lastPos = 0, }; Motor rightWheel = { PIN_MOTOR2, PIN_MOTOR2_IN1, PIN_MOTOR2_IN2, PIN_MOTOR2_OUT1, PIN_MOTOR2_OUT2, .DIR = -1, motor, readSpd, .lastPos = 0, }; main.c #include \"motor.h\"#include \u003cstdio.h\u003e void *usrInterrupt(vo","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:2:1","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"Rust 与并发编程 假期短暂, 我的第一次尝试以失败告终. 之后在网课之余, 机缘巧合, 我接触到了 Rust 这门语言. 简单看了看 the book 发现还不错, 于是花了三周多, 在网课之余把它看完了. 其中 ownership 和 borrow checker 非常特别, 它们规定: 对一个变量的引用(指针), 只能存在: 有且仅有一个独占引用(写者), 且没有共享引用(读者), 或 没有独占引用(写着), 任意多个共享引用(读者) 换句话说, 只要有人在写, 其他任何读写操作都不能进行. 等等, 我之前的编码器计数是怎么实现的? 违背了这个规范呀! 一年后的今天, 让我们彻底了结这个问题: 数据争用. 我用的 Raspbian 是 32 位版本, 其 long long 被定义为 64 位有符号整型. 换句话说, 绝大部分对 64 位整数的操作都不能在一条汇编指令中完成. 因此, 当测速线程修改了速度变量却还没完成时, 有可能被调度打断(raspbian 并不是实时系统). 此时读取这个变量就会发生数据争用的问题. 至于 C 代码为什么没问题, 是因为仅仅打印了编码器计数, 而没有另起一个测速线程. 中断处理速度极快且不会被其他线程抢占, 而中断发生的频率又没有高到能够常常打断主线程中的读取过程. 我翻 makefile 才发现我 C 开了 O3, C++啥优化也没开… 那么, 合理的解决办法是什么呢? 原子操作 atom 是不可分的意思, 原子操作就是不会被打断的操作. 缺点是需要处理器支持, 且一般只能操作长度不大于处理器字长的数据类型. 关于 Ordering 的选择, 如果只需要原子性, 使用 Ordering::Relax 即可, 用于计数的话再适合不过了. 在多核情况下还需要考虑内存一致性来选择 Ordering, 最严格的一般是 Ordering::SeqCst. 互斥锁\\读写锁 (普通线程) 对于有操作系统(包括实时系统)情况下普通线程间的资源共享, 可以使用这两种锁. 详见 the book. 如果获取锁失败, 线程可以选择出让控制权让操作系统先调度其他线程. 临界区(中断) 由于中断总能抢占当前线程, 除非你允许中断处理函数在资源被占用的情况下漏掉中断不处理, 否则主线程中的锁形同虚设. 有的处理器可以暂时关闭所有中断, 这样当前正在执行的任务就不会被打断. 如果使用 rust, 还需要配合 Mutex, RefCell 等来通过语法检查, 详见 the embedded rust book. 缓冲区 还有一种取巧的做法, 使用内存来通信. 环形缓冲区可以实现为数组+头尾原子指针, 我们可以让发送端独占头指针, 接收端独占尾指针, 每次发送/接收,都向内存中写入/读取数据后操作指针自增. 只要缓冲区够大且接收端处理速度大于发送端发送速度, 一般不会漏掉消息. 保险起见还可以在发送和/或接收时加上头尾指针判断 如果现在让我重新设计树莓派编码器测速逻辑: 我会使用中断操作原子类型计数, 用互斥锁包装速度全局变量, 让测速线程和主线程抢锁, 来保证对速度变量的操作不会产生竟态条件. 不过, 后来实习接触了 STM32 这样的单片机, 拿来做平衡小车足够了, 反观树莓派 4B 还需要 5V3A 供电, 我还特意买了微雪的电池扩展版, 头顶两节 18650 简直不要太笨重, 于是树莓派就光荣的吃灰了. STM32 的定时器具有编码器功能, 可以通过每次读取后清零的方法获取速度, 配合定时器中断测速即可. 不过我用 rust 实现的版本因为软件 I2C 的库必须要一个定时器, 导致没定时器拿来做中断了… 只好用延时实现. ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:2:2","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"多传感器融合 还记得 MPU6050 有个 DMP 库吗? 后来转向 Rust + STM32 后, 因为没找到能用的 DMP 库, 我就用的六轴原始数据. 确定角度还不简单? 三轴加速度和重力一比较就完事儿了, 我用的库还有现成的包装 get_acc_angles(\u0026mut self) -\u003e Result\u003cVector2, Mpu6050Error\u003e. 快快拿来一试, 再加上现成的 PID 库, P 输入用刚才获得的角度, D 输入直接用陀螺仪, 不到一个小时代码就编译通过了. 不得不说, Rust 这点真的香: 99%的情况下能过编译就能跑. 小车拿在手里, 前倾就向前加速, 后倾就向后加速, 各参数极性正确! 但是 PID 参数我竟然调了三天都没调明白…连最基本的姿态环都几乎无法实现. 最好的一组参数也只能维持个 10 秒钟左右. 我干脆两手捏住轮子当成纯倒立摆, 诶!?怎么这都稳定不了? 看了输出才发现, 获取到的角度抖动太大! 那就加平滑滤波! 可加了滤波也没法稳定, 这让我又犯了难… 想想也是, 这小车本身就在抖动, 读出来的加速度可不仅仅是重力加速度. 那要怎么确定角度呢? 有以下几种办法: ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:3:0","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"互补滤波 $$ \\theta = k \\cdot \\theta_{\\text{acc}} + (1-k)\\cdot \\int{{\\omega}dt} $$ 通过对读取到的角速度 $\\omega$ 积分, 我们也可以得到一个角度数据 $\\theta_\\text{gyro}$. 当然这个数据会因为累加存在一定的误差. 之前提到从加速度计和重力方向也可以得到一个角度数据 $\\theta_\\text{acc}$, 我们把两个数据分辨乘以一定的权重后相加, 作为上述控制系统的输入. 在实际实现时, 往往采用递推的方式将其改写为: $$ \\theta_{i+1} = k \\cdot \\theta_{\\text{acc}} + (1-k)\\cdot ({\\theta_{i} + \\omega dt}) $$ 还可以根据当前两个数据的大小来动态调整权重, 比如: 当加速度计测到一个较大数据时, 更相信陀螺仪. 当陀螺仪数据很小时, 更相信加速度计. 本来想用 Rust 在 STM32 上实现互补滤波的, 但因为之前提到的定时器不够只能在 main 函数中 delay 测速来完成整个控制循环, 实践发现这个延时并不稳定, 导致陀螺仪积分要乘的 $dt$ 不好确定. 最后还是决定转回 C, 有 DMP 不用, 何苦呢. ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:3:1","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"卡尔曼滤波 久仰卡尔曼滤波大名, 可惜我水平不够还没看明白原理… 如果有现成的库可以使用, 自然是拿来主义. 我尝试了 rust 的 adskalman, 但因为编译出的二进制太大没能成功烧录. 关于卡尔曼滤波的原理, 希望自己以后可以补充完全. ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:3:2","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"总结 最后用 C 和 DMP 完成的版本效果如下. 时间紧张, 代码质量太差, 就不献丑了. 平衡小车, 搞明白原理其实并不难. 如果我一上来就选了 arduino, 或许就不会接触到 Rust 和 STM32. 从树莓派一路踩坑下来, 反倒收获了更多的知识和经验. ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:4:0","tags":null,"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"这段时间在实习和个人项目中学习 STM32 上嵌入式 Rust 的一些总结 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:0:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"资料 The Book: 熟悉 Rust 语法, 其中并发部分的 channel 和 Mutex, Cell, RefCell 等, 在嵌入式中有类似的用法 Discovery: 写博客时发现这本书有了使用 micro:bit 的新版, 我读的是使用 STM32F3Discovery 的旧版 The Embedded Rust Book: 有嵌入式开发经验可以跳过 discovery 直接看这本. 我买了 F3 板子所以直接跑在板子上没有用 QEMU RTIC: 一个裸机多任务框架, 更好地共享 Rust 变量. 我看的时候是 v0.5, 现在已经出到 1.0 了, 可喜可贺. ferrous-systems’s blog: 这家公司的博客介绍了许多 Rust 在嵌入式开发中的技巧, 获益匪浅. 尤其是实现了一个 async/await executor ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:1:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"环境搭建 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"Rust 工具链 这里使用 rustup 安装了 msvc 工具链的 rust 按需下载对应平台的 core, 否则无法编译: rustup target add thumbv6m-none-eabi # Cortex-M0 and Cortex-M0+ rustup target add thumbv7m-none-eabi # Cortex-M3 rustup target add thumbv7em-none-eabi # Cortex-M4 and Cortex-M7 (no FPU) rustup target add thumbv7em-none-eabihf # Cortex-M4F and Cortex-M7F (with FPU) ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:1","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"调试工具 我使用包管理器 scoop, 以下工具scoop install 即可 arm-none-eabi-gdb openocd 此外,如果使用 ST-LINK, 需要手动安装驱动 这篇文章末尾提供了使用 vscode 调试的方法, 我觉得 gdb 命令行就够用了, 因此没有尝试 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:2","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"Hello World 仅限 cortex-m 内核, 其他平台未研究 cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart 修改 .cargo/config.toml 修改 memory.x 一般 STM32 FLASH 起始地址在 0x08000000, RAM 在 0x20000000. 芯片手册里如果有多段 RAM, 取第一段的大小 修改 openocd.cfg, 可用的配置文件可以在 openocd 的安装目录下找到 在项目目录下执行openocd, 不要关闭这个终端 另起一个终端,执行cargo run, 观察是否收到输出 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:3:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"PAC \u0026 HAL PACPeripheral Access Crate 一般由 svd2rust 根据 ARM 厂商提供的SVDCMSIS System View Description文件自动生成, 提供了寄存器操作的基本包装, API 用法如: pwm.ctl.modify(|r,w|w.globalsync0().clear_bit()); HALHardware Abstract Layer 在 PAC 基础上遵循 embedded-hal 编写. 但至少 STM32 各系列的实现略有区别, 导致同样的外设在 f1, f4 系列上的代码可能大不一样, 各芯片的 driver crate 也不一定都能使用. 部分外设如 FSMC, 因为 hal 没有编写相关部分, 几乎只能靠手动配置寄存器并引入 unsafe 块才能使用 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:4:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"起手式(裸机) #![no_main]/* main使用entry宏引入 */#![no_std]/* 不使用std因为不可用 */usepanic_semihostingas_;/* 选择panic处理方式, 不接调试器semihosting会卡死 */// use panic_halt as _; // use panic_abort as _; /* 需要nightly工具链 */ // use cortex_m::asm; /* 如果需要直接使用汇编指令 */ usecortex_m_rt::entry;// use cortex_m_semihosting::hprintln; /* semihosting下的println!宏, 方便调试 */ // use core::fmt::Write; /* 如果使用串口调试, 使用write!宏向串口tx输出 */ usehal::{delay::Delay,/* 常用的延时 */pac,/* hal包装过的pac */prelude::*,};usestm32f1xx_halashal;/* 导入一个hal */#[entry]fn main()-\u003e !{let(dp,cp)=(/* dp:device peripherals, 指MCU厂商扩展的外设 */pac::Peripherals::take().unwrap(),/* cp: core peripherals, 指ARM自带的外设 */cortex_m::Peripherals::take().unwrap(),);/* 配置时钟 */let(mutflash,mutrcc)=(dp.FLASH.constrain(),dp.RCC.constrain());letclocks=rcc.cfgr.use_hse(8.mhz()).freeze(\u0026mutflash.acr);/* 初始化delay对象, 这里用系统时钟SYST */letmutdelay=Delay::new(cp.SYST,clocks);/* gpio抽象, 各hal略有不同 */let(mutgpioa,mutgpiob)=(dp.GPIOA.split(\u0026mutrcc.apb2),dp.GPIOB.split(\u0026mutrcc.apb2));loop{/* do something */}}``` ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:5:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"safe 全局变量 我们都知道操作 static mut 是 unsafe 的, 大量的编程规范要求尽量减少使用全局变量. 但嵌入式环境下往往无法避免. 一个更好的方法是规划好变量的作用范围后使用 RTIC. 不过这里先讲一下简单的做法和原理 Atomic 是平台支持下最优雅的做法, 简洁, 安全. 缺点是不能进行有复杂逻辑的操作, 且仅支持几种基本数据类型, 不过一般需求下够用了. Mutex\u003cRefCell\u003cT\u003e\u003e 配合临界区使用. 需要use cortex_m::interrupt::{self, Mutex};. 可以包装更复杂的数据类型, 包括外设. 但会引入大量语法噪音. 使用方法大致为: 声明一个 static FOO:Mutex\u003cRefCell\u003cOption\u003cT\u003e\u003e\u003e = Mutex::new(RefCell::new(None)); 在 main 中初始化外设并在临界区中使用 interrupt::free(|cs| FOO.borrow(cs).replace(Some(T))); 移动所有权给全局变量 FOO 使用时同样需要进入临界区后, 使用 FOO.borrow(cs).borrow() 获取RefCell后再 as_ref() 才能得到内部的 T 我几乎从不使用这种方法, 心累手也累, 复杂项目直接上 RTIC 完事儿 这部分相当让人抓狂, 许多在 C 语言中可以直接写的部分要包上好多层, 即便我知道它是安全的. ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:6:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"RTIC 我很想管 RTIC 叫抢占式调度框架, 如果搭配内存分配器, 用起来和抢占式的 RTOS 没啥区别. 然而它其实只是个前后台系统, 靠设置中断优先级来管理任务, 并不具有上下文切换的能力. 用它的原因就在于它包装了上述复杂的 Mutex\u003cRefCell\u003cOption\u003cT\u003e\u003e\u003e, 并可以将空闲的硬中断注册为可以有参数和容量的多个软中断. 然而, 缺点来自于它使用了大量的宏, 导致无论 RLSRust Language Server 还是 RARust Analyzer 都不能很好的支持自动补全和类型. 有些报错会一直显示却不影响正常编译… 真正编不过时又找不到报错的原因. 因此我经常先在裸机上搭好一些外设驱动框架, 调试好类型后再复制进 RTIC 项目. ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:7:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"内存分配器 alloc-cortex-m: 需要 nightly 工具链, 用法 使用内存分配器后, 可以像有 std 一样使用方便地使用 vec! 等. 可以先通过 FSMC 配置好外部 RAM 后将其内存起始地址指向 RAM ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:8:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"RTOS 我尝试过drone, WSL 和 Linux 物理机都试过, 然而连 hello world 都没能跑起来… 它似乎也没在更新了 另外还有Tock OS, 但外设驱动需要自行编写, 官方的 ST demo 只有 f3disco 和两个 f4nucleo, 并没有尝试过 RTOS 方面估计很难超越 μCOS 和 FreeRTOS, 大量芯片驱动都有现成的 C 代码, Rust 这边还只能用爱发电. OS 能否和现有的 hal 框架兼容还是个问题 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:9:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"常用 crate heapless: 提供了静态内存分配的常用数据类型 HistoryBuffer: 可用于平滑滤波 spsc::Queue: 消息队列 String: 方便输出调试信息 bitbang-hal: 提供了软件模拟的 I2C, USART, SPI nb: 虽然名字叫做 non-block 但更多用 block!宏来等待外设工作完成, 例如: block!(Serial.write(byte))?; micromath: 提供了嵌入式环境下可能缺失的某些 F32 操作 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:10:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"总结 个人项目的话, Embedded Rust 只能说差强人意. 小芯片 debug 编译二进制太大, 没法调试. 语法噪音也是相当烦人. 我利用几个芯片的 crate 写了个平衡车玩, 过段时间会专门介绍 实习中用 rust 写了一些小板子的验证 demo, 逻辑简单的话用 hal 分分钟就能起个项目. 也用 RTIC 尝试过复杂项目, 有这么几个问题: 本质仍然是前后台, 复杂任务调度比较烧脑 运行速度比 μCOSⅢ 慢不少, 写了个简单的串口环回, 能慢将近一半. 或许是我时钟没配好…也可能人家商业公司在关中断这块儿确实优化的好. 尝试了两天, 还是改用 μCOS 了, 因为即便我这个实习生写出来也以后没人接手维护… Rust 合理的 trait 抽象加上 embedded-hal 这套统一的规范, 使得各种库的编写成为可能. 我的平衡车项目几乎纯靠调库就能完成, 可见这套抽象的威力. 这也是 STM32 的标准库和 HAL 库 之所以火遍中国. 然而现实很骨感, 一是性能损失, 这种抽象多少会带来一些冗余代码, 当然 LLVM 能不能优化我就不懂了; 二是虽然有 embedded-hal 规定了一些 trait, 但 trait 之外的部分各不相同, 就比如 ST 系列, FSMC 几乎没有, F1XXHAL 和 F4XXHAL 许多 api 完全不同… 最后一点纯属猜测, C++ 也有虚函数, 也完全可以定义一套接口规范, 为何 ARM 厂商不用 C++ 呢? 虚表实现有性能损失, 那编译器也可以用其他实现呀, 反正芯片厂的编译器都是魔改过的…这么多年 C++ 都没在嵌入式铺开, Rust 只能说悬 Rust 是个好语言, 但在嵌入式方面生态似乎是更主要的问题. 没有解决大痛点的话业界根本没有动力抛弃多年积累重新开始. ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:11:0","tags":null,"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["misc"],"content":"记录一下我的博客历程 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:0:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Notion 搞一个博客的想法由来已久，2017 年接触到 notion，文章可以开启外链，当博客用完全没问题。然而国内访问不稳定，以及——不好看，于是迟迟没有动手。目前主要把 notion 的 database 作为跨平台收藏夹、偶尔写一些较重的 todo list 便于跨平台访问。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:1:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Pelican 2019 年大一期间找点事做，接触到 Github Pages 与静态博客工具，因为相对熟悉 Python 选择了 Pelican。断断续续开发到 2020 年暑假结束，接触了很多前端知识。最后的效果差强人意，虽然确实部署了一两篇文章，但总因为外观不舒心而没有动力更新。在此期间了解了 Hexo Next1, Hugo Meme2等等基于其他博客平台的主题，确定了自己期望的几个主要功能： dark mode：以前常驻深色模式，但宿舍采光很好，导致白天只能调高亮度用白色模式，夜晚只能调低亮度用深色模式，否则眼睛难受。我的博客自然也应具备这个功能。实现上就是用 js 做两套 css 的切换。具体到深色模式的配色设计，又有很多细节，以及 svg 的适配等等，也是个小坑。 responsive：适配移动端，本质上是 css 的 media 属性。折叠菜单等又需要 js 配合。 toctable of contents：Meme2可以说满足 99% 的需求，除了没有侧边目录，导致只能线性阅读。更适合杂文而非技术类博客。 一个好看的顶栏，起码 sticky 定位 $\\LaTeX$：KaTeX 或 MathJax markdown 扩展语法 中文：一个好看的中文字体，Meme2所用的思源宋体Noto Serif SC真是太棒了 图片：支持图片下方标注，合理的缩放 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:2:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Hugo ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Meme2 如同上文所述，尝试拼一个侧边目录进去，技术力不够调不好看，作罢。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:1","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Eureka 这个主题的 doc 模式启发了另一种组织文章的方式。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:2","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"LoveIt 相当惊艳的主题，功能丰富，完成度高。看到之后别无所求了。然而似乎没有再更新了，有意向转向 DoIt，不过先把 LoveIt 折腾明白吧。 https://github.com/iissnan/hexo-theme-next ↩︎ https://io-oi.me 他的文章也很有意思 ↩︎ ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:3","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"}]